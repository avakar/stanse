<?xml version="1.0" encoding="UTF-8" ?>
<automaton>
    <description name="pointer analysis automaton checker"
                 desc="Handles common problems when using pointer such as
                       null/dangling pointer dereference, double free, and
                       memory leaks." />

    <start state="U" />
    <transition from="U[A]" by="malloc[A]" to="I[A]" />
    <transition from="N[A]" by="malloc[A]" to="I[A]" />
    <transition from="D[A]" by="malloc[A]" to="I[A]" />
    <transition from="U[A]" by="null[A]" to="N[A]" />
    <transition from="D[A]" by="null[A]" to="N[A]" />
    <transition from="I[A]" by="null[A]" to="N[A]" />
    <transition from="I[A]" by="notnull[A]" to="V[A]" />
    <transition from="V[A]" by="free[A]" to="D[A]" />
    <transition from="I[A]" by="free[A]" to="D[A]" />

    <error  from="U[A]" by="free[A]"
            desc="releasing of unallocated memory."
            level="0"
            entry="pointer is not initialized at function entry."
            begin="pointer is not initialized."
            propag="not affected ==> pointer is still not initialized."
            end="pointer is not initialized, but is released here." />

    <error  from="I[A]" by="free[A]"
            desc="releasing unallocated memory."
            level="0"
            entry="pointer is not initialized at function entry."
            begin="pointer does not point to valid memory."
            propag="not affected ==> pointer still does not point to valid memory."
            end="pointer is not initialized, but is released here." />

    <error  from="N[A]" by="free[A]"
            desc="releasing unallocated memory."
            level="0"
            entry=""
            begin="pointer points to NULL."
            propag="not affected ==> pointer still points to NULL."
            end="pointer points to NULL, but is released here." />

    <error  from="D[A]" by="free[A]"
            desc="releasing already released memory"
            level="0"
            entry=""
            begin="memory is released here -> pointer becames dangling."
            propag="not affected ==> pointer is still dangling."
            end="pointer is dangling and releasing it here." />

    <error  from="I[A]" by="malloc[A]"
            desc="memory leak"
            level="0"
            entry=""
            begin="pointer is pointing to the valid memory."
            propag="not affected ==> still pointing to valid memory."
            end="the only reference to valid memory is lost here." />

    <error  from="V[A]" by="malloc[A]"
            desc="memory leak"
            level="0"
            entry=""
            begin="pointer is pointing to the valid memory."
            propag="not affected ==> still pointing to valid memory."
            end="the only reference to valid memory is lost here." />

    <error  from="U[A]" by="deref[A]"
            desc="dereferencing invalid pointer"
            level="0"
            entry="pointer is invalid at function entry."
            begin="pointer is invalid here."
            propag="not affected ==> pointer is still invalid."
            end="dereferencing invalid pointer here." />

    <error  from="I[A]" by="deref[A]"
            desc="dereferencing invalid pointer"
            level="0"
            entry="pointer does not point to valid memory at function entry."
            begin="pointer does not point to valid memory."
            propag="not affected ==> pointer still does not point to valid memory."
            end="dereferencing invalid pointer here." />

    <error  from="N[A]" by="deref[A]"
            desc="dereferencing invalid pointer"
            level="0"
            entry="pointer does not point to valid memory at function entry."
            begin="pointer does not point to valid memory."
            propag="not affected ==> pointer still does not point to valid memory."
            end="dereferencing invalid pointer here." />

    <error  from="D[A]" by="deref[A]"
            desc="dereferencing invalid pointer"
            level="0"
            entry="pointer does not point to valid memory at function entry."
            begin="pointer does not point to valid memory."
            propag="not affected ==> pointer still does not point to valid memory."
            end="dereferencing invalid pointer here." />

    <error  from="N[A]" by="null[A]"
            desc="unnecessary check (checking for NULL)."
            level="0"
            entry="pointer is NULL at function entry."
            begin="pointer is NULL here."
            propag="not affected ==> pointer is still NULL."
            end="pointer always points to NULL here, but checking for it." />

    <error  from="V[A]" by="null[A]"
            desc="unnecessary check (checking for NULL)."
            level="0"
            entry="pointer is valid at function entry."
            begin="pointer is valid here."
            propag="not affected ==> pointer is still valid."
            end="pointer always points valid memory here, but checking for it." />

    <error  from="V[*]" by=""
            desc="leaving function without releasing memory - memory leak"
            level="0"
            entry=""
            begin="pointer points to valid memory."
            propag="not affected ==> pointer still points to valid memory."
            end="Leaving function and only reference to valid memory is lost here." />

    <error  from="I[*]" by=""
            desc="leaving function without releasing memory - memory leak"
            level="0"
            entry=""
            begin="pointer points to valid memory."
            propag="not affected ==> pointer still points to valid memory."
            end="Leaving function and only reference to valid memory is lost here." />

    <pattern name="malloc">
        <assignExpression>
            <var name="A" />
            <functionCall>
                <id>malloc</id>
                <ignore />
            </functionCall>
        </assignExpression>
    </pattern>

    <pattern name="malloc">
        <assignExpression>
            <var name="A" />
            <castExpression>
                <ignore />
                <functionCall>
                    <id>malloc</id>
                    <ignore />
                </functionCall>
            </castExpression>
        </assignExpression>
    </pattern>

    <pattern name="free">
        <functionCall>
            <id>free</id>
            <var name="A"/>
        </functionCall>
    </pattern>

    <pattern name="deref">
        <nested exclude0="sizeofExpression">
            <derefExpression>
                <var name="A" constructive="false" />
            </derefExpression>
        </nested>
    </pattern>

    <pattern name="deref">
        <nested exclude0="sizeofExpression">
            <arrowExpression>
                <var name="A" constructive="false" />
                <ignore />
            </arrowExpression>
        </nested>
    </pattern>

    <pattern name="deref">
        <nested exclude0="sizeofExpression">
            <arrayAccess>
                <var name="A" constructive="false" />
                <ignore />
            </arrayAccess>
        </nested>
    </pattern>

    <!-- Matches condition of form:
        if (A) {
	    assert(A);
        } else {
	    assert(!A);
        }
    -->
    <pattern name="notnull">
        <assert>
	    <var name="A" constructive="false" match="{id}{arrowExpression}{arrayAccess}{dotExpression}" />
        </assert>
    </pattern>
    <pattern name="null">
        <assert>
	    <prefixExpression op="!">
		<var name="A" constructive="false" match="{id}{arrowExpression}{arrayAccess}{dotExpression}" />
	    </prefixExpression>
        </assert>
    </pattern>

    <!-- Matches condition of form:
        if (!A) {
	    assert(!A); // done above
        } else {
	    assert(!!A);
        }
    -->
    <pattern name="notnull">
        <assert>
	    <prefixExpression op="!">
		<prefixExpression op="!">
                    <var name="A" constructive="false" />
		</prefixExpression>
	    </prefixExpression>
        </assert>
    </pattern>

    <!-- Matches condition of form:
        if (A == 0) {
	    assert(A == 0);
        } else {
	    assert(!(A == 0));
        }
    -->
    <pattern name="null">
        <assert>
	    <binaryExpression op="==">
		<var name="A" constructive="false" />
		<intConst>0</intConst>
	    </binaryExpression>
        </assert>
    </pattern>
    <pattern name="notnull">
        <assert>
	    <prefixExpression op="!">
		<binaryExpression op="==">
                    <var name="A" constructive="false" />
                    <intConst>0</intConst>
		</binaryExpression>
	    </prefixExpression>
        </assert>
    </pattern>

    <!-- Matches condition of form:
        if (A == (T*)0) {
	    assert(A == (T*)0);
        } else {
	    assert(!(A == (T*)0));
        }
    -->
    <pattern name="null">
        <assert>
	    <binaryExpression op="==">
		<var name="A" constructive="false" />
		<castExpression>
		    <ignore />
		    <intConst>0</intConst>
		</castExpression>
	    </binaryExpression>
        </assert>
    </pattern>
    <pattern name="notnull">
        <assert>
	    <prefixExpression op="!">
		<binaryExpression op="==">
		    <var name="A" constructive="false" />
		    <castExpression>
			<ignore />
			<intConst>0</intConst>
		    </castExpression>
		</binaryExpression>
	    </prefixExpression>
        </assert>
    </pattern>

    <!-- Matches condition of form:
        if (A != 0) {
	    assert(A != 0);
        } else {
	    assert(!(A != 0));
        }
    -->
    <pattern name="notnull">
        <assert>
	    <binaryExpression op="!=">
		<var name="A" constructive="false" />
		<intConst>0</intConst>
	    </binaryExpression>
        </assert>
    </pattern>
    <pattern name="null">
        <assert>
	    <prefixExpression op="!">
		<binaryExpression op="!=">
		    <var name="A" constructive="false" />
		    <intConst>0</intConst>
		</binaryExpression>
	    </prefixExpression>
        </assert>
    </pattern>

    <!-- Matches condition of form:
        if (A != (T*)0) {
	    assert(A != (T*)0);
        } else {
	    assert(!(A != (T*)0));
        }
    -->
    <pattern name="notnull">
        <assert>
	    <binaryExpression op="!=">
		<var name="A" constructive="false" />
		<castExpression>
		    <ignore />
		    <intConst>0</intConst>
		</castExpression>
	    </binaryExpression>
        </assert>
    </pattern>
    <pattern name="null">
        <assert>
	    <prefixExpression op="!">
		<binaryExpression op="!=">
		    <var name="A" constructive="false" />
		    <castExpression>
			<ignore />
			<intConst>0</intConst>
		    </castExpression>
		</binaryExpression>
	    </prefixExpression>
        </assert>
    </pattern>

    <!-- Matches condition of form:
        if (0 == A) {
	    assert(0 == A);
        } else {
	    assert(!(0 == A));
        }
    -->
    <pattern name="null">
        <assert>
	    <binaryExpression op="==">
		<intConst>0</intConst>
		<var name="A" constructive="false" />
	    </binaryExpression>
        </assert>
    </pattern>
    <pattern name="notnull">
        <assert>
	    <prefixExpression op="!">
		<binaryExpression op="==">
		    <intConst>0</intConst>
		    <var name="A" constructive="false" />
		</binaryExpression>
	    </prefixExpression>
        </assert>
    </pattern>

    <!-- Matches condition of form:
        if ((T*)0 == A) {
	    assert((T*)0 == A);
        } else {
	    assert(!((T*)0 == A));
        }
    -->
    <pattern name="null">
        <assert>
	    <binaryExpressionEquality>
		<castExpression>
		    <ignore />
		    <intConst>0</intConst>
		</castExpression>
		<var name="A" constructive="false" />
	    </binaryExpressionEquality>
        </assert>
    </pattern>
    <pattern name="notnull">
        <assert>
	    <prefixExpression op="!">
		<binaryExpressionEquality>
		    <castExpression>
			<ignore />
			<intConst>0</intConst>
		    </castExpression>
		    <var name="A" constructive="false" />
		</binaryExpressionEquality>
	    </prefixExpression>
        </assert>
    </pattern>

    <!-- Matches condition of form:
        if (0 != A) {
	    assert(0 != A);
        } else {
	    assert(!(0 != A));
        }
    -->
    <pattern name="notnull">
        <assert>
	    <binaryExpression op="!=">
		<intConst>0</intConst>
		<var name="A" constructive="false" />
	    </binaryExpression>
        </assert>
    </pattern>
    <pattern name="null">
        <assert>
	    <prefixExpression op="!">
		<binaryExpression op="!=">
		    <intConst>0</intConst>
		    <var name="A" constructive="false" />
		</binaryExpression>
	    </prefixExpression>
        </assert>
    </pattern>

    <!-- Matches condition of form:
        if ((T*)0 != A) {
	    assert((T*)0 != A);
        } else {
	    assert(!((T*)0 != A));
        }
    -->
    <pattern name="notnull">
        <assert>
	    <binaryExpression op="!=">
		<castExpression>
		    <ignore />
		    <intConst>0</intConst>
		</castExpression>
		<var name="A" constructive="false" />
	    </binaryExpression>
        </assert>
    </pattern>
    <pattern name="null">
        <assert>
	    <prefixExpression op="!">
		<binaryExpression op="!=">
		    <castExpression>
			<ignore />
			<intConst>0</intConst>
		    </castExpression>
		    <var name="A" constructive="false" />
		</binaryExpression>
	    </prefixExpression>
        </assert>
    </pattern>

</automaton>
